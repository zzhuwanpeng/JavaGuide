+  基于数据库
基于数据库的分布式锁有两种实现方案：

-基于排他锁

互斥性：获取锁时新增一条记录，并对锁对应的行加排他锁，阻塞其他试图获取该锁的请求。

容错性：持有锁的Client断开连接时由数据库的连接超时机制保证排他锁锁被释放以实现容错性。

缺点：1. 如果多个线程同时间长时间持有锁会导致数据库连接过多；2. 数据库单点风险。

-基于唯一键

互斥性：建立具有唯一字段的表。获取锁时向表中新增一条数据，如果成功表示加锁成功，如果出现唯一键冲突说明对应的锁已被占用。

容错性：设置超时阈值，由定时任务定期删除表内记录

缺点：1. 如果持有锁的时间区间太长会被误删，导致锁错误地进入释放状态；2. 数据库单点风险。

+  基于分布式一致性算法
基于分布式一致性算法实现分布式锁，可以使用ZooKeeper，etcd，Chubby等等，以下以ZooKeeper版本为例：

互斥性：获取锁时新建临时节点（或租约节点），视为该节点对应的锁已被占用。

容错性：临时节点的生命周期为ZooKeeper的Session内，持有锁的客户端与ZooKeeper Session断开时节点自动消除，认为是锁被释放。

缺点：会有惊群效应，影响ZooKeeper性能。原因是客户端尝试获取锁失败（锁被其他线程占用）时，在对应的临时节点上添加Watcher，如果大量客户端同时请求锁会导致添加大量Watcher。

+ 基于分布式缓存
此方案主要依赖"SET if Not eXists"机制（即只有不存在的时候才设置）实现。以Redis为例：

互斥性：使用Redis的SETNX原语加锁，如果失败表明该锁已被其他线程持有；

容错性：由expireTime保证超时机制。如果持有锁的客户端超过expireTime仍未主动释放锁，Redis会使对应的key过期，强制释放锁；

缺点：1. 如果持有锁的时间区间太长会被误删，导致锁错误地进入释放状态；2. Redis集群设计初衷在于性能而不在于数据一致性。如果Redis丢失数据将导致导致锁错误地进入释放状态。

+ RedLock方案

缺陷二产生的原因在于Redis副本间的数据复制是异步进行，主从切换之后可能有部分数据没有复制完成，因此可能会丢失锁。针对此情况，使用Redlock进行改进。此时直接连接到多个Redis Master(例如5个)，加锁时同时向所有Master请求，得到其中大部分（最少3个）Success回应时视为加锁成功。此方案虽然一定程度上提升了集群的可靠性，但不能完全解决Redis集群失效带来的风险。例如同时大于2个集群失效，此时无法使用锁
