## 基础
### HashMap 
头插法死循环，使用尾插法，多线程下丢失节点，
        红黑树，算法稳定，链表log(n),链表的长度大于8 且数组的长度大于64时，此时链表会转为红黑树
        容量是2的次幂，因为位运算取模效率高，hash函数更均匀，扩容效率高
        
### Hashtable 
是线程安全的，方法级的锁，效率低

## 多线程
### 锁
Sychronized和ReenterLock：
功能上：ReentrantLock，可以实现公平锁，尝试加锁(trylock),超时，显示加锁释放，支持中断
       都是可重入的，效率上差不多
底层上：Sychronized是JVM级别的，通过对象上的monitor变量监视，有等待队列，自旋
       ReenterLock是AQS实现，由state + 阻塞队列实现
两者都是悲观锁，但ReenterLock提供了乐观锁的机制，通过tryLock()后，再判断版本号实现

### 线程池
参数：核心线程数，最大线程数，阻塞队列，拒绝策略(AbortPolicy,直接拒接)，存活时间（非核心线程空闲等待时间），时间单位
核心线程中的线程，通过take() 阻塞，直到任务到来

### wait和sleep
都会让出cpu，但sleep不释放锁，wait会释放锁


## spring
### springmvc
filter ： 函数回调
inteceptor： 反射

### IOC&AOP
IOC: 管理调用引用对象的权利交给了spring
AOP：带接口的是动态代理，不带接口的是GClib，aspectj是字节码实现


### 自动装配
@EnableAutoConfiguration： 可以扫描第三方未标注注解的jar，通过扫描jar包下的META-INF/spring.factories

## 存储

### mysql
#### b树和b+树的区别
B+树是B树的变种，所有的数据记录都存储在叶子节点，而内部节点只存储关键字，不存储数据记录，这样提高了查询效率。
在B+树中，叶子节点通过指针连接成一个链表，便于范围查询和顺序访问，而B树则没有这样的结构。

#### 事务隔离级别
读未提交，读已提交，不可重复读，串行化
第三个RR是默认的
幻读通过(MVCC和间隙锁控制)
MVCC：当前读和快照读


#### redo undolog

#### limit的性能

### redis
大key：


### es
#### 深度分页
使用searchAfter 需要有一个排序字段。
适用于页面分页。游标的方式一次性快照，适合数据导出，量太大。

#### 选举策略
最小id法，从每个节点随机选择其他的节点中的一个开始
角色：leader，follower，协调节点，数据节点


### Hbase
按列存储
如果有多个列族 ，一行数据库中的rowkey会被存储在多个hfile中
rowkey的前缀设计非常重要

用途：社交，好友关系（因为是稀疏矩阵），点赞，收藏数等等

## 分布式
### 微服务设计 ，DDD


### duboo

六大核心功能：
负载均衡：随机，轮询，最少活跃数，最短响应时间，一致性hash
三个中心：注册中心(zk,nacos)，配置中心(nacos)，元数据中心
支持失败重试，服务降级
底层调用：Netty，Mina；上次传输协议：dubbo3：Trible（grpc）

### MQ


### 分布式基础组件
#### 分布式锁
redis，zk：
redis： 高性能，set操作)+lua（(原子性）， requestId + 超时 + finnaly(释放锁)
ZK： 一致性，zk临时节点，多了节点watch会产生惊群效应。

#### 分布式ID
雪花算法
美团leaf：每次取一个段，然后双buffer
美团分布式唯一ID的算法核心是Leaf——一种基于Snowflake算法改进的分布式ID生成系统。Leaf通过结合时间戳、工作机器ID和序列号来生成唯一的ID，确保在分布式环境中的唯一性和顺序性。此外，Leaf还提供了两种模式：Leaf-segment数据库号段模式和Leaf-snowflake时钟回拨优化模式，以适应不同的业务场景和性能需求。

时钟回拨问题：
检测时钟回拨：在生成ID时，系统会检查当前时间是否比最后一次生成ID的时间戳小，如果是，说明发生了时钟回拨。
等待时间追赶：如果检测到时钟回拨，系统不会立即生成新的ID，而是等待直到系统当前时间追赶到最后一次记录的时间戳。这个等待过程保证了在时间戳维度上ID的唯一性

#### 分布式事务

#### 分库分表


## 大数据





        
